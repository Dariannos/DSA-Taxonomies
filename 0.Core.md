# Data Structure & Algorithm Pattern Taxonomy

This directory contains categorizations of common algorithm patterns and techniques organized by type. Each taxonomy file provides a comprehensive breakdown of a specific pattern, including:

- Hierarchical organization of sub-patterns and variants
- Descriptions of when and how to apply each technique
- Example LeetCode problems that demonstrate each pattern
- Cross-references to related patterns

## Available Taxonomies

### Core Data Structures
- [[Linked List Pattern]] - Linear collections with efficient insertions and deletions (~75+ problems)
- [[Hash Table]] - O(1) lookup, insertion, and deletion operations (~150+ problems)
- [[Stack & Queue Pattern]] - LIFO and FIFO data structures for ordered processing (~100+ problems)
- [[Heap & Priority Queue Pattern]] - Efficiently finding extreme values (~50+ problems)
- [[Trie Pattern]] - Specialized tree structures for string operations (~40+ problems)

### Fundamental Algorithms
- [[Binary Search]] - Efficient searching in sorted collections (~100+ problems)
- [[Two Pointers]] - Using multiple pointers to optimize array/list operations (~100+ problems)
- [[Traversal Algorithms Pattern]] - Systematically exploring data structures (DFS: ~125+ problems, BFS: ~70+ problems)
- [[Union Find Pattern]] - Managing disjoint sets efficiently (~30+ problems)

### Advanced Algorithms
- [[Dynamic Programming Pattern]] - Breaking complex problems into simpler subproblems (~240+ problems)
- [[Backtracking Pattern]] - Building solutions incrementally with trial and error (~50+ problems)
- [[Greedy Algorithms Pattern]] - Making locally optimal choices (~100+ problems)
- [[Bit Manipulation Pattern]] - Working with binary representation (~130 problems)

## How to Use This Taxonomy

1. **Identify the pattern**: When faced with a new problem, try to recognize which general pattern it belongs to
2. **Find the specific sub-pattern**: Navigate to the appropriate category to understand variations and implementations
3. **Study similar problems**: Review the linked example problems to understand practical applications
4. **Look for cross-pattern solutions**: Some problems can be solved with multiple approaches

## Pattern Selection Guide

- **Arrays/Strings**: Start with Two Pointers and Sliding Window
- **Searching**: Master Binary Search for sorted collections and optimization problems
- **Trees/Graphs**: Focus on Traversal Algorithms (DFS/BFS) and Union Find
- **Optimization Problems**: Study Dynamic Programming, Greedy, and Binary Search on answer space
- **Combinatorial Problems**: Concentrate on Backtracking and Bit Manipulation
- **Efficiency Concerns**: Hash Table techniques are essential for O(1) lookups

## Study Priority Based on Problem Frequency

Based on the distribution of problems on LeetCode, here's a suggested study order:

### High Priority (100+ problems each)
1. Dynamic Programming ✅DONE
2. Hash Table ✅DONE
3. Graph & Tree Traversals (DFS/BFS) ✅DONE
4. Binary Search ✅DONE
5. Two Pointers ✅DONE

### Medium Priority (50-100 problems each)
1. Stack & Queue ✅DONE
2. Heap & Priority Queue ✅DONE
3. Backtracking ✅DONE
4. Linked List ✅DONE
5. Greedy Algorithms ✅DONE

### Specialized Topics (fewer problems but important for interviews)
1. Bit Manipulation ✅DONE
2. Trie Algorithms ✅DONE
3. Union Find ✅DONE
4. Segment Tree / Binary Indexed Tree
5. Advanced Graph Algorithms

## Contributing

To add new patterns or improve existing taxonomies:

1. Follow the established format for consistency
2. Include problem references with LeetCode numbers when available
3. Add clear descriptions for each category
4. Create cross-references to related patterns where appropriate