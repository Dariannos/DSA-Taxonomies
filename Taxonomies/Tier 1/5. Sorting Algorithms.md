# Sorting Algorithms Pattern Taxonomy

> Sorting algorithms organize data in a specific order, enabling efficient searching, data analysis, and serving as building blocks for more complex algorithms.

```
└── Sorting Algorithms Pattern
    │
    ├── Comparison-Based Sorting
    │   │   /* Algorithms that compare elements directly */
    │   │
    │   ├── ─ O(n²) Comparison Sorts
    │   │   │   /* Simple but inefficient sorting algorithms */
    │   │   │   ├── Bubble Sort
    │   │   │   │   /* Repeatedly swaps adjacent elements */
    │   │   │   │   ├── Implementation: "Bubble Sort"
    │   │   │   │   └── Problem: "283. Move Zeroes" (bubble sort concept)
    │   │   │   │
    │   │   │   ├── Selection Sort
    │   │   │   │   /* Finds minimum and places at beginning */
    │   │   │   │   ├── Implementation: "Selection Sort" 
    │   │   │   │   └── Problem: "215. Kth Largest Element in an Array" (selection concept)
    │   │   │   │
    │   │   │   └── Insertion Sort
    │   │   │       /* Builds sorted array one element at a time */
    │   │   │       ├── Implementation: "Insertion Sort"
    │   │   │       ├── Problem: "147. Insertion Sort List"
    │   │   │       └── Problem: "Maintaining a sorted list"
    │   │   │
    │   │   ├── ─ O(n log n) Divide & Conquer Sorts
    │   │   │   │   /* Efficient sorting using recursive division */
    │   │   │   │   ├── Merge Sort
    │   │   │   │   │   /* Divide, sort, and merge */
    │   │   │   │   │   ├── Implementation: "912. Sort an Array"
    │   │   │   │   │   ├── Problem: "21. Merge Two Sorted Lists" (merge operation)
    │   │   │   │   │   ├── Problem: "148. Sort List" (on linked list)
    │   │   │   │   │   └── Problem: "493. Reverse Pairs" (merge sort with counting)
    │   │   │   │   │
    │   │   │   │   ├── Quick Sort
    │   │   │   │   │   /* Partition around pivot */
    │   │   │   │   │   ├── Implementation: "912. Sort an Array"
    │   │   │   │   │   ├── Problem: "215. Kth Largest Element in an Array" (quickselect)
    │   │   │   │   │   ├── Problem: "973. K Closest Points to Origin" (quickselect)
    │   │   │   │   │   └── Problem: "75. Sort Colors" (Dutch national flag)
    │   │   │   │   │
    │   │   │   │   └── Heap Sort
    │   │   │   │       /* Selection sort using a heap */
    │   │   │   │       ├── Implementation: "Heap Sort"
    │   │   │   │       ├── Problem: "215. Kth Largest Element in an Array"
    │   │   │   │       └── Problem: "347. Top K Frequent Elements"
    │   │   │
    │   │   └── ─ Specialized Comparison Sorts
    │   │       │   /* Sorts optimized for specific scenarios */
    │   │       │   ├── Tim Sort
    │   │       │   │   /* Hybrid of merge sort and insertion sort */
    │   │       │   │   ├── Application: "Python's built-in sort"
    │   │       │   │   └── Use Case: "Real-world sorting with partial ordering"
    │   │       │   │
    │   │       │   ├── Shell Sort
    │   │       │   │   /* Generalized insertion sort with decreasing gaps */
    │   │       │   │   └── Application: "Sorting nearly sorted arrays"
    │   │       │   │
    │   │       │   └── Introsort
    │   │       │       /* Hybrid of quicksort, heapsort, and insertion sort */
    │   │       │       └── Application: "C++'s std::sort"
    │   │
    │   └── Non-Comparison Sorts
    │       │   /* Sorting without direct element comparisons */
    │       │
    │       ├── ─ Linear Time Sorts
    │       │   │   /* O(n) sorting for specific data types */
    │       │   │   ├── Counting Sort
    │       │   │   │   /* Sorts by counting occurrences */
    │       │   │   │   ├── Implementation: "Counting Sort"
    │       │   │   │   ├── Problem: "75. Sort Colors"
    │       │   │   │   ├── Problem: "274. H-Index" (counting concept)
    │       │   │   │   └── Problem: "1122. Relative Sort Array"
    │       │   │   │
    │       │   │   ├── Radix Sort
    │       │   │   │   /* Sorts by digit positions */
    │       │   │   │   ├── Implementation: "Radix Sort"
    │       │   │   │   ├── Problem: "164. Maximum Gap"
    │       │   │   │   └── Problem: "Sorting large integers"
    │       │   │   │
    │       │   │   └── Bucket Sort
    │       │   │       /* Distributes into buckets then sorts */
    │       │   │       ├── Implementation: "Bucket Sort" 
    │       │   │       ├── Problem: "347. Top K Frequent Elements"
    │       │   │       └── Problem: "451. Sort Characters By Frequency"
    │       │
    │       └── ─ Specialized Non-Comparison Sorts
    │           │   /* Special-purpose sorting techniques */
    │           │   ├── Pigeonhole Sort
    │           │   │   /* Special case of counting sort */
    │           │   │   └── Application: "Sorting integers in a small range"
    │           │   │
    │           │   └── Flash Sort
    │           │       /* Distribution-based algorithm */
    │           │       └── Application: "Nearly sorted data with uniform distribution"
    │
    ├── Partial Sorting & Selection
    │   │   /* Finding specific elements without full sorting */
    │   │
    │   ├── ─ Quickselect
    │   │   │   /* Finding kth smallest/largest element */
    │   │   │   ├── Problem: "215. Kth Largest Element in an Array"
    │   │   │   ├── Problem: "973. K Closest Points to Origin"
    │   │   │   └── Problem: "347. Top K Frequent Elements"
    │   │   │
    │   │   ├── ─ Median Finding
    │   │   │   │   /* Efficient median computation */
    │   │   │   │   ├── Problem: "295. Find Median from Data Stream"
    │   │   │   │   └── Problem: "480. Sliding Window Median"
    │   │   │
    │   │   └── ─ Heap-Based Selection
    │   │       │   /* Using heaps for selection problems */
    │   │       │   ├── Problem: "378. Kth Smallest Element in a Sorted Matrix"
    │   │       │   ├── Problem: "373. Find K Pairs with Smallest Sums"
    │   │       │   └── Problem: "692. Top K Frequent Words"
    │
    ├── Sorting Applications
    │   │   /* Using sorting to solve problems */
    │   │
    │   ├── ─ Interval Problems
    │   │   │   /* Sorting intervals/ranges */
    │   │   │   ├── Problem: "56. Merge Intervals"
    │   │   │   ├── Problem: "57. Insert Interval"
    │   │   │   └── Problem: "253. Meeting Rooms II"
    │   │   │
    │   │   ├── ─ Greedy Algorithms + Sorting
    │   │   │   │   /* Sorting as a preprocessing step */
    │   │   │   │   ├── Problem: "455. Assign Cookies"
    │   │   │   │   ├── Problem: "1029. Two City Scheduling" 
    │   │   │   │   └── Problem: "881. Boats to Save People"
    │   │   │
    │   │   └── ─ Custom Sorting
    │   │       │   /* Problem-specific sorting logic */
    │   │       │   ├── Problem: "179. Largest Number"
    │   │       │   ├── Problem: "406. Queue Reconstruction by Height"
    │   │       │   └── Problem: "937. Reorder Data in Log Files"
    │
    └── Advanced Sorting Concepts
        │   /* Complex sorting techniques */
        │
        ├── ─ External Sorting
        │   │   /* Sorting data that doesn't fit in memory */
        │   │   ├── Application: "Sorting large files"
        │   │   └── Technique: "Multi-way merge sort"
        │
        ├── ─ Parallel Sorting
        │   │   /* Sorting using multiple processors */
        │   │   ├── Application: "Sorting big data"
        │   │   └── Technique: "Parallel merge sort"
        │
        └── ─ Sorting Networks
            │   /* Fixed-comparison sequence for sorting */
            │   ├── Application: "Bitonic sort"
            │   └── Technique: "Sorting in hardware"
```

> **Related Patterns**: 
> - Two Pointers (essential for partition operations)
> - Divide and Conquer (basis for efficient sorting algorithms)
> - Heap (used in Heap Sort and selection algorithms)
> - Greedy Algorithms (often combined with sorting)
