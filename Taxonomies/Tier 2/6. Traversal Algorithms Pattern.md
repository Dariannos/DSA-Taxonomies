# Traversal Algorithms Pattern Taxonomy

> Traversal algorithms systematically visit all elements in a data structure, using different strategies based on the structure and problem requirements.

```
└── Traversal Algorithms Pattern
    │
    ├── Tree Traversals
    │   │   /* Systematic ways to visit all nodes in a tree */
    │   │
    │   ├── ─ Depth-First Search (DFS) Variants
    │   │   │   /* Explore as far as possible along a branch before backtracking */
    │   │   │
    │   │   ├── ── Recursive DFS
    │   │   │   │   /* Implementation using function call stack */
    │   │   │   │   ├── Preorder Traversal (Root → Left → Right)
    │   │   │   │   │   ├── Problem: "144. Binary Tree Preorder Traversal"
    │   │   │   │   │   ├── Problem: "589. N-ary Tree Preorder Traversal"
    │   │   │   │   │   └── Application: "257. Binary Tree Paths"
    │   │   │   │   │
    │   │   │   │   ├── Inorder Traversal (Left → Root → Right)
    │   │   │   │   │   ├── Problem: "94. Binary Tree Inorder Traversal"
    │   │   │   │   │   ├── Problem: "98. Validate Binary Search Tree"
    │   │   │   │   │   └── Problem: "230. Kth Smallest Element in a BST"
    │   │   │   │   │
    │   │   │   │   ├── Postorder Traversal (Left → Right → Root)
    │   │   │   │   │   ├── Problem: "145. Binary Tree Postorder Traversal"
    │   │   │   │   │   ├── Problem: "590. N-ary Tree Postorder Traversal"
    │   │   │   │   │   └── Problem: "124. Binary Tree Maximum Path Sum"
    │   │   │   │   │
    │   │   │   │   └── Path-Based DFS
    │   │   │   │       /* Finding specific paths in trees */
    │   │   │   │       ├── Root-to-Leaf Paths
    │   │   │   │       │   ├── Problem: "112. Path Sum"
    │   │   │   │       │   └── Problem: "113. Path Sum II"
    │   │   │   │       │
    │   │   │   │       ├── Any Path (Node-to-Node)
    │   │   │   │       │   ├── Problem: "437. Path Sum III"
    │   │   │   │       │   └── Problem: "687. Longest Univalue Path"
    │   │   │   │       │
    │   │   │   │       └── Ancestor-Descendant Relationships
    │   │   │   │           ├── Problem: "236. Lowest Common Ancestor of a Binary Tree"
    │   │   │   │           └── Problem: "1644. Lowest Common Ancestor of a Binary Tree II"
    │   │   │
    │   │   ├── ── Iterative DFS (Stack-based)
    │   │   │   │   /* Implementation using explicit stack */
    │   │   │   │   ├── Explicit Stack Traversals
    │   │   │   │   │   ├── Problem: "144. Binary Tree Preorder Traversal"
    │   │   │   │   │   ├── Problem: "94. Binary Tree Inorder Traversal"
    │   │   │   │   │   └── Problem: "145. Binary Tree Postorder Traversal"
    │   │   │   │   │
    │   │   │   │   └── State-Tracking DFS
    │   │   │   │       /* Using additional state information */
    │   │   │   │       ├── Problem: "331. Verify Preorder Serialization of a Binary Tree"
    │   │   │   │       └── Problem: "1008. Construct Binary Search Tree from Preorder Traversal"
    │   │   │
    │   │   └── ── Morris Traversal (O(1) Space)
    │   │       │   /* DFS without using stack or recursion */
    │   │       │   ├── Morris Inorder
    │   │       │   │   ├── Problem: "94. Binary Tree Inorder Traversal"
    │   │       │   │   └── Problem: "99. Recover Binary Search Tree"
    │   │       │   │
    │   │       │   └── Morris Preorder
    │   │       │       └── Problem: "144. Binary Tree Preorder Traversal"
    │   │
    │   ├── ─ Breadth-First Search (BFS) Variants
    │   │   │   /* Level by level traversal using a queue */
    │   │   │
    │   │   ├── ── Level-Order Traversals
    │   │   │   │   /* Processing nodes level by level */
    │   │   │   │   ├── Standard Level Order
    │   │   │   │   │   ├── Problem: "102. Binary Tree Level Order Traversal"
    │   │   │   │   │   ├── Problem: "107. Binary Tree Level Order Traversal II"
    │   │   │   │   │   └── Problem: "429. N-ary Tree Level Order Traversal"
    │   │   │   │   │
    │   │   │   │   ├── Level-wise Processing
    │   │   │   │   │   /* Working with entire levels */
    │   │   │   │   │   ├── Problem: "199. Binary Tree Right Side View"
    │   │   │   │   │   ├── Problem: "515. Find Largest Value in Each Tree Row"
    │   │   │   │   │   └── Problem: "116. Populating Next Right Pointers in Each Node"
    │   │   │   │   │
    │   │   │   │   └── Depth-Based Analysis
    │   │   │   │       /* Analyzing tree by depth */
    │   │   │   │       ├── Problem: "104. Maximum Depth of Binary Tree"
    │   │   │   │       ├── Problem: "111. Minimum Depth of Binary Tree"
    │   │   │   │       └── Problem: "662. Maximum Width of Binary Tree"
    │   │   │
    │   │   ├── ── Multi-Source BFS
    │   │   │   │   /* Starting BFS from multiple nodes */
    │   │   │   │   └── Simultaneous Expansion
    │   │   │   │       ├── Problem: "1161. Maximum Level Sum of a Binary Tree"
    │   │   │   │       └── Problem: "1302. Deepest Leaves Sum"
    │   │   │
    │   │   └── ── Bidirectional BFS
    │   │       │   /* BFS from both source and target */
    │   │       │   └── Meeting-Point Search
    │   │           └── Problem: "863. All Nodes Distance K in Binary Tree"
    │   │
    │   ├── ─ Specialized Tree Traversals
    │   │   │   /* Advanced or problem-specific traversals */
    │   │   │
    │   │   ├── ── Boundary Traversals
    │   │   │   │   /* Following the outline of the tree */
    │   │   │   │   └── Problem: "545. Boundary of Binary Tree"
    │   │   │
    │   │   ├── ── Vertical Traversals
    │   │   │   │   /* Based on horizontal distance from root */
    │   │   │   │   └── Problem: "987. Vertical Order Traversal of a Binary Tree"
    │   │   │
    │   │   ├── ── Spiral/Zigzag Patterns
    │   │   │   │   /* Alternating direction by level */
    │   │   │   │   └── Problem: "103. Binary Tree Zigzag Level Order Traversal"
    │   │   │
    │   │   └── ── View-Based Traversals
    │   │       │   /* What's visible from different perspectives */
    │   │       │   ├── Side Views
    │   │       │   │   └── Problem: "199. Binary Tree Right Side View"
    │   │       │   │
    │   │       │   └── Top/Bottom Views
    │   │       │       └── Problem: "314. Binary Tree Vertical Order Traversal"
    │   │
    │   └── ─ Tree Construction via Traversals
    │       │   /* Building trees from traversal sequences */
    │       │   ├── From Multiple Traversals
    │       │   │   ├── Problem: "105. Construct Binary Tree from Preorder and Inorder Traversal"
    │       │   │   └── Problem: "106. Construct Binary Tree from Inorder and Postorder Traversal"
    │       │   │
    │       │   └── Serialization/Deserialization
    │       │       /* Converting trees to/from string representations */
    │       │       ├── Problem: "297. Serialize and Deserialize Binary Tree"
    │       │       └── Problem: "449. Serialize and Deserialize BST"
    │
    ├── Graph Traversals
    │   │   /* Algorithms for visiting all vertices/edges in a graph */
    │   │
    │   ├── ─ Depth-First Search (DFS) on Graphs
    │   │   │   /* Exploring deep paths before backtracking */
    │   │   │
    │   │   ├── ── Connected Components
    │   │   │   │   /* Finding isolated subgraphs */
    │   │   │   │   ├── Basic Connectivity
    │   │   │   │   │   ├── Problem: "200. Number of Islands"
    │   │   │   │   │   └── Problem: "547. Number of Provinces"
    │   │   │   │   │
    │   │   │   │   └── Component Size Analysis
    │   │   │   │       ├── Problem: "695. Max Area of Island"
    │   │   │   │       └── Problem: "1254. Number of Closed Islands"
    │   │   │
    │   │   ├── ── Cycle Detection
    │   │   │   │   /* Finding loops in graphs */
    │   │   │   │   ├── Undirected Graph Cycles
    │   │   │   │   │   └── Problem: "684. Redundant Connection"
    │   │   │   │   │
    │   │   │   │   └── Directed Graph Cycles
    │   │   │   │       ├── Problem: "207. Course Schedule"
    │   │   │   │       └── Problem: "802. Find Eventual Safe States"
    │   │   │
    │   │   ├── ── Path Finding & Exploration
    │   │   │   │   /* Finding routes between vertices */
    │   │   │   │   ├── All Paths
    │   │   │   │   │   └── Problem: "797. All Paths From Source to Target"
    │   │   │   │   │
    │   │   │   │   └── Path Existence
    │   │   │   │       └── Problem: "1971. Find if Path Exists in Graph"
    │   │   │
    │   │   └── ── Topological Sort
    │   │       │   /* Ordering vertices based on dependencies */
    │   │       │   ├── DFS-Based Topological Sort
    │   │       │   │   ├── Problem: "210. Course Schedule II"
    │   │       │   │   └── Problem: "269. Alien Dictionary"
    │   │       │   │
    │   │       │   └── Lexicographic Ordering
    │   │       │       └── Problem: "953. Verifying an Alien Dictionary"
    │   │
    │   ├── ─ Breadth-First Search (BFS) on Graphs
    │   │   │   /* Level by level exploration */
    │   │   │
    │   │   ├── ── Shortest Path (Unweighted)
    │   │   │   │   /* Finding paths with minimum number of edges */
    │   │   │   │   ├── Single Source Shortest Path
    │   │   │   │   │   ├── Problem: "1091. Shortest Path in Binary Matrix"
    │   │   │   │   │   ├── Problem: "994. Rotting Oranges"
    │   │   │   │   │   └── Problem: "127. Word Ladder"
    │   │   │   │   │
    │   │   │   │   └── Level-by-Level Expansion
    │   │   │   │       ├── Problem: "542. 01 Matrix"
    │   │   │   │       └── Problem: "1162. As Far from Land as Possible"
    │   │   │
    │   │   ├── ── Multi-Source BFS
    │   │   │   │   /* Starting from multiple points */
    │   │   │   │   ├── Simultaneous Propagation
    │   │   │   │   │   ├── Problem: "994. Rotting Oranges"
    │   │   │   │   │   └── Problem: "542. 01 Matrix"
    │   │   │   │   │
    │   │   │   │   └── Boundary Expansion
    │   │   │   │       ├── Problem: "1020. Number of Enclaves"
    │   │   │   │       └── Problem: "130. Surrounded Regions"
    │   │   │
    │   │   ├── ── Bidirectional BFS
    │   │   │   │   /* BFS from both source and target */
    │   │   │   │   └── Meet-in-the-Middle
    │   │   │   │       ├── Problem: "127. Word Ladder"
    │   │   │   │       └── Problem: "752. Open the Lock"
    │   │   │
    │   │   └── ── Topological Sort (Kahn's Algorithm)
    │   │       │   /* BFS-based approach to topological sorting */
    │   │       │   ├── Indegree-Based Processing
    │   │       │   │   ├── Problem: "210. Course Schedule II"
    │   │       │   │   └── Problem: "310. Minimum Height Trees"
    │   │       │   │
    │   │       │   └── Lexicographic Topological Sort
    │   │       │       └── Problem: "1203. Sort Items by Groups Respecting Dependencies"
    │   │
    │   └── ─ Advanced Graph Traversal Patterns
    │       │   /* Specialized algorithms for complex graph problems */
    │       │
    │       ├── ── Union-Find (Disjoint Set Union)
    │       │   │   /* Efficiently track connected components */
    │       │   │   ├── Path Compression + Union by Rank
    │       │   │   │   ├── Problem: "547. Number of Provinces"
    │       │   │   │   └── Problem: "684. Redundant Connection"
    │       │   │   │
    │       │   │   └── Dynamic Connectivity
    │       │   │       └── Problem: "721. Accounts Merge"
    │       │   │
    │       │   ├── ── Shortest Path Algorithms (Weighted)
    │       │   │   │   /* Finding optimal paths with weighted edges */
    │       │   │   │   ├── Dijkstra's Algorithm
    │       │   │   │   │   ├── Problem: "743. Network Delay Time"
    │       │   │   │   │   └── Problem: "1631. Path With Minimum Effort"
    │       │   │   │   │
    │       │   │   │   ├── Floyd-Warshall (All Pairs)
    │       │   │   │   │   └── Problem: "1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance"
    │       │   │   │   │
    │       │   │   │   └── Bellman-Ford (Negative Weights)
    │       │   │   │       └── Problem: "787. Cheapest Flights Within K Stops"
    │       │   │
    │       │   └── ── Minimum Spanning Tree
    │       │       /* Finding a tree that connects all vertices with minimum weight */
    │       │       └── Problem: "1584. Min Cost to Connect All Points"
    │
    ├── Matrix Traversals
    │   │   /* Specialized algorithms for 2D grids */
    │   │
    │   ├── ─ 2D Grid DFS
    │   │   │   /* Depth-first exploration of matrices */
    │   │   │
    │   │   ├── ── Island/Region Problems
    │   │   │   │   /* Dealing with connected cells */
    │   │   │   │   ├── Connected Region Counting
    │   │   │   │   │   ├── Problem: "200. Number of Islands"
    │   │   │   │   │   └── Problem: "695. Max Area of Island"
    │   │   │   │   │
    │   │   │   │   └── Region Modification
    │   │   │   │       ├── Problem: "130. Surrounded Regions"
    │   │   │   │       └── Problem: "417. Pacific Atlantic Water Flow"
    │   │   │
    │   │   ├── ── Path & Route Finding
    │   │   │   │   /* Finding specific paths in grids */
    │   │   │   │   ├── Backtracking-Style Path Search
    │   │   │   │   │   ├── Problem: "79. Word Search"
    │   │   │   │   │   └── Problem: "212. Word Search II"
    │   │   │   │   │
    │   │   │   │   └── Unique Path Counting
    │   │   │   │       ├── Problem: "62. Unique Paths"
    │   │   │   │       └── Problem: "980. Unique Paths III"
    │   │   │
    │   │   └── ── Flood Fill Algorithms
    │   │       │   /* Spreading values from a starting cell */
    │   │       │   └── Color/Value Propagation
    │   │       │       ├── Problem: "733. Flood Fill"
    │   │       │       └── Problem: "1034. Coloring A Border"
    │   │
    │   ├── ─ 2D Grid BFS
    │   │   │   /* Breadth-first exploration of matrices */
    │   │   │
    │   │   ├── ── Shortest Path in Grid
    │   │   │   │   /* Finding minimum steps between cells */
    │   │   │   │   ├── Basic Grid BFS
    │   │   │   │   │   ├── Problem: "1091. Shortest Path in Binary Matrix"
    │   │   │   │   │   └── Problem: "1926. Nearest Exit from Entrance in Maze"
    │   │   │   │   │
    │   │   │   │   └── Constrained Movement
    │   │   │   │       └── Problem: "1293. Shortest Path in a Grid with Obstacles Elimination"
    │   │   │
    │   │   └── ── Multi-Source BFS in Grid
    │   │       │   /* Starting BFS from multiple cells */
    │   │       │   └── Simultaneous Spread
    │   │       │       ├── Problem: "994. Rotting Oranges"
    │   │       │       └── Problem: "1162. As Far from Land as Possible"
    │   │
    │   └── ─ Specialized Matrix Patterns
    │       │   /* Other ways to traverse matrices */
    │       │
    │       ├── ── Diagonal Traversals
    │       │   │   /* Moving along diagonals */
    │       │   │   └── Problem: "498. Diagonal Traverse"
    │       │
    │       ├── ── Spiral Traversals
    │       │   │   /* Moving in spiral pattern */
    │       │   │   ├── Problem: "54. Spiral Matrix"
    │       │   │   └── Problem: "59. Spiral Matrix II"
    │       │
    │       └── ── Shape-Based Traversals
    │           │   /* Following specific geometric patterns */
    │           │   ├── Rotational Traversals
    │           │   │   └── Problem: "48. Rotate Image"
    │           │   │
    │           │   └── Boundary Traversals
    │           │       └── Problem: "1914. Cyclically Rotating a Grid"
    │
    ├── String Traversals
    │   │   /* Techniques for processing strings */
    │   │
    │   ├── ─ Linear String Traversal
    │   │   │   /* One-pass string processing */
    │   │   │
    │   │   ├── ── Character-by-Character Processing
    │   │   │   │   └── Problem: "125. Valid Palindrome"
    │   │   │
    │   │   ├── ── Window-Based Scanning
    │   │   │   │   ├── Problem: "3. Longest Substring Without Repeating Characters"
    │   │   │   │   └── Problem: "76. Minimum Window Substring"
    │   │   │
    │   │   └── ── Pattern Matching
    │   │       │   ├── Problem: "28. Find the Index of the First Occurrence in a String"
    │   │       │   └── Problem: "686. Repeated String Match"
    │   │
    │   ├── ─ Recursive String Traversal
    │   │   │   /* Using recursion on strings */
    │   │   │
    │   │   ├── ── Backtracking on Strings
    │   │   │   │   ├── Problem: "17. Letter Combinations of a Phone Number"
    │   │   │   │   └── Problem: "22. Generate Parentheses"
    │   │   │
    │   │   └── ── String Decomposition
    │   │       │   ├── Problem: "93. Restore IP Addresses"
    │   │       │   └── Problem: "241. Different Ways to Add Parentheses"
    │   │
    │   └── ─ Trie-Based String Traversal
    │       │   /* Using prefix trees for string operations */
    │       │
    │       ├── ── Prefix Matching
    │       │   │   ├── Problem: "208. Implement Trie (Prefix Tree)"
    │       │   │   └── Problem: "211. Design Add and Search Words Data Structure"
    │       │
    │       └── ── Word Dictionary Problems
    │           │   ├── Problem: "212. Word Search II"
    │           │   └── Problem: "648. Replace Words"
    │
    └── Array Traversals
        │   /* Techniques for processing arrays */
        │
        ├── ─ Linear Array Scanning
        │   │   /* Sequential array processing */
        │   │
        │   ├── ── One-Pass Traversal
        │   │   │   ├── Problem: "121. Best Time to Buy and Sell Stock"
        │   │   │   └── Problem: "53. Maximum Subarray"
        │   │
        │   ├── ── Two-Pointer Technique
        │   │   │   /* Using two indices to process arrays */
        │   │   │   ├── Same Direction Pointers
        │   │   │   │   ├── Problem: "26. Remove Duplicates from Sorted Array"
        │   │   │   │   └── Problem: "283. Move Zeroes"
        │   │   │   │
        │   │   │   └── Opposite Direction Pointers
        │   │   │       ├── Problem: "167. Two Sum II - Input Array Is Sorted"
        │   │   │       └── Problem: "15. 3Sum"
        │   │
        │   └── ── Sliding Window
        │       │   /* Using a variable-sized window */
        │       │   ├── Fixed-Size Window
        │       │   │   └── Problem: "643. Maximum Average Subarray I"
        │       │   │
        │       │   └── Variable-Size Window
        │       │       ├── Problem: "3. Longest Substring Without Repeating Characters"
        │       │       └── Problem: "209. Minimum Size Subarray Sum"
        │
        ├── ─ Binary Search Traversal
        │   │   /* Dividing search space in half repeatedly */
        │   │
        │   ├── ── Standard Binary Search
        │   │   │   ├── Problem: "704. Binary Search"
        │   │   │   └── Problem: "35. Search Insert Position"
        │   │
        │   ├── ── Rotated/Modified Arrays
        │   │   │   ├── Problem: "33. Search in Rotated Sorted Array"
        │   │   │   └── Problem: "153. Find Minimum in Rotated Sorted Array"
        │   │
        │   └── ── Answer Space Binary Search
        │       │   /* Searching in the solution space */
        │       │   ├── Problem: "1011. Capacity To Ship Packages Within D Days"
        │       │   └── Problem: "875. Koko Eating Bananas"
        │
        └── ─ Multidimensional Array Traversal
            │   /* Processing arrays with multiple dimensions */
            │
            ├── ── Nested Loops Traversal
            │   │   /* Using nested iterations */
            │   │   └── Problem: "867. Transpose Matrix"
            │
            ├── ── Coordinated Traversal
            │   │   /* Synchronized movement across dimensions */
            │   │   └── Problem: "73. Set Matrix Zeroes"
            │
            └── ── Jump Patterns
                │   /* Non-adjacent element access */
                │   ├── Problem: "1345. Jump Game IV"
                │   └── Problem: "55. Jump Game"
```

> **Related Patterns**: 
> - Binary Search (a specific form of array traversal)
> - Two Pointers (often used in conjunction with traversal)
> - Dynamic Programming (many DP problems rely on specific traversal orders)
> - Graph Algorithms (most use DFS/BFS traversals as their foundation)