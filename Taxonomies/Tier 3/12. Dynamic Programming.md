# Dynamic Programming Pattern Taxonomy

> Dynamic programming solves complex problems by breaking them into simpler subproblems, storing solutions to avoid redundant calculations.

```
└── Dynamic Programming Pattern
    │
    ├── 1D State DP
    │   │   /* Problems with a single state variable */
    │   │
    │   ├── ─ Linear Sequence DP
    │   │   │   /* Solutions built from left to right */
    │   │   │   ├── Classic Problems
    │   │   │   │   ├── Problem: "70. Climbing Stairs" 
    │   │   │   │   ├── Problem: "198. House Robber"
    │   │   │   │   └── Problem: "139. Word Break"
    │   │   │   │
    │   │   │   └── Kadane's Algorithm (Maximum Subarray)
    │   │   │       ├── Problem: "53. Maximum Subarray"
    │   │   │       └── Problem: "152. Maximum Product Subarray"
    │   │   │
    │   │   ├── ─ Decision Making
    │   │   │   │   /* Optimal choice at each position */
    │   │   │   │   ├── Buy/Sell Stock Problems
    │   │   │   │   │   ├── Problem: "121. Best Time to Buy and Sell Stock"
    │   │   │   │   │   ├── Problem: "122. Best Time to Buy and Sell Stock II"
    │   │   │   │   │   └── Problem: "123. Best Time to Buy and Sell Stock III"
    │   │   │   │   │
    │   │   │   │   └── Game Theory
    │   │   │   │       ├── Problem: "877. Stone Game"
    │   │   │   │       └── Problem: "1406. Stone Game III"
    │   │   │
    │   │   └── ─ Fibonacci-Style DP
    │   │       │   /* Next state depends on previous K states */
    │   │       │   ├── Problem: "509. Fibonacci Number"
    │   │       │   ├── Problem: "1137. N-th Tribonacci Number"
    │   │       │   └── Problem: "91. Decode Ways"
    │   │
    │   └── Substring/Subsequence Problems
    │       │   /* Working with portions of sequences */
    │       │
    │       ├── ─ Longest Increasing Subsequence (LIS)
    │       │   │   ├── Problem: "300. Longest Increasing Subsequence"
    │       │   │   ├── Problem: "673. Number of Longest Increasing Subsequences"
    │       │   │   └── Problem: "1048. Longest String Chain"
    │       │
    │       ├── ─ Longest Common Subsequence (LCS)
    │       │   │   ├── Problem: "1143. Longest Common Subsequence"
    │       │   │   ├── Problem: "583. Delete Operation for Two Strings"
    │       │   │   └── Problem: "1092. Shortest Common Supersequence"
    │       │
    │       ├── ─ Edit Distance
    │       │   │   ├── Problem: "72. Edit Distance"
    │       │   │   └── Problem: "115. Distinct Subsequences"
    │       │
    │       └── ─ Palindromic Subsequences
    │           │   ├── Problem: "516. Longest Palindromic Subsequence"
    │           │   └── Problem: "1312. Minimum Insertion Steps to Make a String Palindrome"
    │
    ├── 2D/Multi-Dimensional DP
    │   │   /* Problems with multiple state variables */
    │   │
    │   ├── ─ Grid-Based DP
    │   │   │   /* Problems on 2D matrices */
    │   │   │   ├── Path Problems
    │   │   │   │   ├── Problem: "62. Unique Paths"
    │   │   │   │   ├── Problem: "64. Minimum Path Sum"
    │   │   │   │   └── Problem: "63. Unique Paths II"
    │   │   │   │
    │   │   │   ├── Region Problems
    │   │   │   │   ├── Problem: "221. Maximal Square"
    │   │   │   │   ├── Problem: "85. Maximal Rectangle"
    │   │   │   │   └── Problem: "1277. Count Square Submatrices with All Ones"
    │   │   │   │
    │   │   │   └── Grid Traversal with Constraints
    │   │   │       ├── Problem: "120. Triangle"
    │   │   │       └── Problem: "931. Minimum Falling Path Sum"
    │   │   │
    │   │   └── ─ Interval DP
    │   │       │   /* Problems involving ranges or intervals */
    │   │       │   ├── Problem: "312. Burst Balloons"
    │   │       │   ├── Problem: "1039. Minimum Score Triangulation of Polygon"
    │   │       │   └── Problem: "1547. Minimum Cost to Cut a Stick"
    │   │
    │   └── Knapsack Problems
    │       │   /* Resource allocation with constraints */
    │       │
    │       ├── ─ 0/1 Knapsack
    │       │   │   /* Take or leave each item */
    │       │   │   ├── Problem: "416. Partition Equal Subset Sum"
    │       │   │   ├── Problem: "494. Target Sum"
    │       │   │   └── Problem: "474. Ones and Zeroes"
    │       │
    │       ├── ─ Unbounded Knapsack
    │       │   │   /* Can use items multiple times */
    │       │   │   ├── Problem: "322. Coin Change"
    │       │   │   ├── Problem: "518. Coin Change 2"
    │       │   │   └── Problem: "377. Combination Sum IV"
    │       │
    │       └── ─ Multi-constraint Knapsack
    │           │   /* Multiple limiting factors */
    │           │   └── Problem: "1155. Number of Dice Rolls With Target Sum"
    │
    ├── State Compression DP
    │   │   /* Using bits to represent states */
    │   │
    │   ├── ─ Bitmask DP
    │   │   │   /* Using binary representation for state */
    │   │   │   ├── Problem: "78. Subsets"
    │   │   │   ├── Problem: "1349. Maximum Students Taking Exam"
    │   │   │   └── Problem: "698. Partition to K Equal Sum Subsets"
    │   │
    │   └── ─ Traveling Salesman Problem (TSP)
    │       │   /* Finding optimal path visiting all nodes */
    │       │   ├── Problem: "943. Find the Shortest Superstring"
    │       │   └── Problem: "980. Unique Paths III"
    │
    └── DP Optimization Techniques
        │   /* Methods to improve efficiency */
        │
        ├── ─ Space Optimization
        │   │   /* Reducing memory usage */
        │   │   ├── Rolling Array
        │   │   │   └── Problem: "70. Climbing Stairs" (optimized)
        │   │   │
        │   │   └── State Reduction
        │   │       └── Problem: "121. Best Time to Buy and Sell Stock" (optimized)
        │
        ├── ─ Divide and Conquer DP
        │   │   /* Combining D&C with DP */
        │   │   └── Problem: "1335. Minimum Difficulty of a Job Schedule"
        │
        └── ─ Monotonic Queue/Stack Optimization
            │   /* Using auxiliary data structures */
            │   └── Problem: "1425. Constrained Subsequence Sum"
```

> **Related Patterns**: 
> - Recursion (DP often optimizes recursive solutions)
> - Greedy Algorithms (sometimes provides alternative to DP)
> - Backtracking (exhaustive search vs. memoization)
> - Divide and Conquer (shares subproblem approach)
