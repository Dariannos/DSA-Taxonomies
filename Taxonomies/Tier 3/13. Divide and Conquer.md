# Divide and Conquer Pattern Taxonomy

> Divide and conquer is an algorithmic paradigm that breaks a problem into smaller subproblems, solves them independently, and then combines their solutions to solve the original problem, often enabling efficient solutions through recursion.

```
└── Divide and Conquer Pattern
    │
    ├── Classic Divide and Conquer Algorithms
    │   │   /* Fundamental D&C algorithms */
    │   │
    │   ├── ─ Sorting Algorithms
    │   │   │   /* Sorting through recursive division */
    │   │   │   ├── Merge Sort
    │   │   │   │   ├── Problem: "912. Sort an Array"
    │   │   │   │   ├── Problem: "148. Sort List"
    │   │   │   │   └── Problem: "315. Count of Smaller Numbers After Self"
    │   │   │   │
    │   │   │   ├── Quick Sort
    │   │   │   │   ├── Problem: "912. Sort an Array"
    │   │   │   │   └── Problem: "215. Kth Largest Element in an Array" (Quickselect)
    │   │   │   │
    │   │   │   └── External Sorting Applications
    │   │   │       ├── Technique: "Multi-way merge sort"
    │   │   │       └── Application: "Sorting large files"
    │   │   │
    │   │   ├── ─ Binary Search
    │   │   │   │   /* Finding elements by halving search space */
    │   │   │   │   ├── Basic Binary Search
    │   │   │   │   │   ├── Problem: "704. Binary Search"
    │   │   │   │   │   └── Problem: "35. Search Insert Position"
    │   │   │   │   │
    │   │   │   │   ├── Rotated Array Search
    │   │   │   │   │   ├── Problem: "33. Search in Rotated Sorted Array"
    │   │   │   │   │   └── Problem: "153. Find Minimum in Rotated Sorted Array"
    │   │   │   │   │
    │   │   │   │   └── Matrix Binary Search
    │   │   │   │       ├── Problem: "74. Search a 2D Matrix"
    │   │   │   │       └── Problem: "240. Search a 2D Matrix II"
    │   │   │
    │   │   └── ─ Selection Algorithms
    │   │       │   /* Finding specific elements without full sorting */
    │   │       │   ├── Quickselect
    │   │       │   │   ├── Problem: "215. Kth Largest Element in an Array"
    │   │       │   │   └── Problem: "973. K Closest Points to Origin"
    │   │       │   │
    │   │       │   └── Median of Medians
    │   │       │       └── Application: "Worst-case linear time selection"
    │   │
    │   └── Mathematical D&C
    │       │   /* Applying D&C to mathematical problems */
    │       │
    │       ├── ─ Integer Multiplication
    │       │   │   /* Efficient large number multiplication */
    │       │   │   ├── Karatsuba Algorithm
    │       │   │   │   └── Application: "Fast multiplication of large integers"
    │       │   │   │
    │       │   │   └── Fast Fourier Transform (FFT)
    │       │   │       └── Application: "Polynomial multiplication"
    │       │
    │       ├── ─ Matrix Operations
    │       │   │   /* Efficient matrix manipulations */
    │       │   │   ├── Strassen's Matrix Multiplication
    │       │   │   │   └── Application: "Fast matrix multiplication"
    │       │   │   │
    │       │   │   └── Matrix Exponentiation
    │       │   │       ├── Problem: "509. Fibonacci Number" (matrix approach)
    │       │   │       └── Problem: "70. Climbing Stairs" (matrix approach)
    │       │
    │       └── ─ Fast Exponentiation
    │           │   /* Efficient power calculation */
    │           │   ├── Binary Exponentiation
    │           │   │   ├── Problem: "50. Pow(x, n)"
    │           │   │   └── Problem: "372. Super Pow"
    │           │   │
    │           │   └── Modular Exponentiation
    │           │       └── Application: "Cryptography operations"
    │
    ├── Array and String D&C
    │   │   /* D&C applied to sequence problems */
    │   │
    │   ├── ─ Subarray Problems
    │   │   │   /* Finding subarrays with specific properties */
    │   │   │   ├── Maximum Subarray
    │   │   │   │   ├── Problem: "53. Maximum Subarray"
    │   │   │   │   └── Problem: "918. Maximum Sum Circular Subarray"
    │   │   │   │
    │   │   │   ├── Closest Pair
    │   │   │   │   ├── Problem: "16. 3Sum Closest" (divide approach)
    │   │   │   │   └── Application: "Closest pair of points in 2D space"
    │   │   │   │
    │   │   │   └── Counting Problems
    │   │   │       ├── Problem: "315. Count of Smaller Numbers After Self"
    │   │   │       ├── Problem: "493. Reverse Pairs"
    │   │   │       └── Problem: "327. Count of Range Sum"
    │   │   │
    │   │   ├── ─ String Manipulation
    │   │   │   │   /* D&C for string operations */
    │   │   │   │   ├── Longest Common Prefix
    │   │   │   │   │   └── Problem: "14. Longest Common Prefix"
    │   │   │   │   │
    │   │   │   │   ├── String Matching
    │   │   │   │   │   └── Application: "Rabin-Karp algorithm with D&C"
    │   │   │   │   │
    │   │   │   │   └── Palindrome Problems
    │   │   │   │       ├── Problem: "5. Longest Palindromic Substring"
    │   │   │   │       └── Problem: "647. Palindromic Substrings"
    │   │   │
    │   │   └── ─ Range Query Problems
    │   │       │   /* Efficient queries over ranges */
    │   │       │   ├── Segment Tree Applications
    │   │       │   │   ├── Problem: "307. Range Sum Query - Mutable"
    │   │       │   │   └── Problem: "715. Range Module"
    │   │       │   │
    │   │       │   └── Binary Indexed Tree Applications
    │   │       │       └── Problem: "315. Count of Smaller Numbers After Self"
    │   │
    │   └── Computational Geometry
    │       │   /* D&C for geometric problems */
    │       │   ├── Closest Pair of Points
    │       │   │   └── Application: "Finding closest points in 2D plane"
    │       │   │
    │       │   ├── Convex Hull
    │       │   │   └── Application: "Graham scan using D&C"
    │       │   │
    │       │   └── Geometric Intersections
    │       │       └── Application: "Line segment intersection"
    │
    ├── Tree and Graph D&C
    │   │   /* D&C on hierarchical structures */
    │   │
    │   ├── ─ Tree Problems
    │   │   │   /* Recursive solutions on trees */
    │   │   │   ├── Tree Construction
    │   │   │   │   ├── Problem: "105. Construct Binary Tree from Preorder and Inorder Traversal"
    │   │   │   │   ├── Problem: "106. Construct Binary Tree from Inorder and Postorder Traversal"
    │   │   │   │   └── Problem: "889. Construct Binary Tree from Preorder and Postorder Traversal"
    │   │   │   │
    │   │   │   ├── Tree Properties
    │   │   │   │   ├── Problem: "543. Diameter of Binary Tree"
    │   │   │   │   ├── Problem: "124. Binary Tree Maximum Path Sum"
    │   │   │   │   └── Problem: "1373. Maximum Sum BST in Binary Tree"
    │   │   │   │
    │   │   │   └── Lowest Common Ancestor
    │   │   │       ├── Problem: "236. Lowest Common Ancestor of a Binary Tree"
    │   │   │       └── Problem: "1644. Lowest Common Ancestor of a Binary Tree II"
    │   │   │
    │   │   └── ─ Graph Algorithms
    │   │       │   /* D&C strategies for graphs */
    │   │       │   ├── Graph Connectivity
    │   │       │   │   ├── Application: "Finding bridges and articulation points"
    │   │       │   │   └── Application: "Tarjan's algorithm"
    │   │       │   │
    │   │       │   ├── Shortest Path Problems
    │   │       │   │   └── Application: "Johnson's algorithm for all pairs shortest paths"
    │   │       │   │
    │   │       │   └── Divide and Conquer Optimization for DP
    │   │       │       └── Problem: "1335. Minimum Difficulty of a Job Schedule"
    │   │
    │   └── D&C in Parallel Computing
    │       │   /* Leveraging D&C for parallelization */
    │       │   ├── Map-Reduce Paradigm
    │       │   │   └── Application: "Big data processing"
    │       │   │
    │       │   └── Parallel Sorting Algorithms
    │       │       └── Application: "Parallel merge sort"
    │
    └── Advanced D&C Techniques
        │   /* Specialized D&C approaches */
        │
        ├── ─ Master Theorem Applications
        │   │   /* Analyzing recurrence relations */
        │   │   ├── Application: "Time complexity analysis of D&C algorithms"
        │   │   └── Technique: "Solving T(n) = aT(n/b) + f(n)"
        │
        ├── ─ D&C with Memoization
        │   │   /* Combining D&C with dynamic programming */
        │   │   ├── Problem: "241. Different Ways to Add Parentheses"
        │   │   ├── Problem: "95. Unique Binary Search Trees II"
        │   │   └── Problem: "312. Burst Balloons"
        │
        └── ─ Specialized D&C Paradigms
            │   /* Custom D&C strategies */
            │   ├── Divide and Conquer DP Optimization
            │   │   ├── Problem: "1335. Minimum Difficulty of a Job Schedule"
            │   │   └── Technique: "Optimizing DP transitions using monotonicity"
            │   │
            │   └── Parallelizable D&C
            │       ├── Application: "MapReduce algorithms"
            │       └── Technique: "Embarrassingly parallel problems"
```

> **Related Patterns**: 
> - Dynamic Programming (D&C with overlapping subproblems)
> - Binary Search (a specialized form of D&C)
> - Greedy Algorithms (sometimes an alternative to D&C)
> - Recursion (fundamental to implementing D&C)
